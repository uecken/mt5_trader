<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MT5 TraderÊÄùËÄÉËß£Êûê & Â£≤Ë≤∑„Ç∑„Çπ„ÉÜ„É†</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        .header {
            background: #16213e;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .header h1 {
            font-size: 1.3rem;
            color: #4cc9f0;
        }
        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label {
            font-size: 0.85rem;
            color: #aaa;
        }
        select, input {
            background: #0f3460;
            border: 1px solid #4cc9f0;
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        select:focus, input:focus {
            outline: none;
            border-color: #7b2cbf;
        }
        button {
            background: #4cc9f0;
            color: #1a1a2e;
            border: none;
            padding: 8px 20px;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover {
            background: #7b2cbf;
            color: #fff;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        .btn-start {
            background: #26a69a;
        }
        .btn-start:hover {
            background: #2bbbad;
        }
        .btn-stop {
            background: #ef5350;
        }
        .btn-stop:hover {
            background: #ff6b68;
        }
        .main-container {
            display: flex;
            height: calc(100vh - 70px);
        }
        #chart-container {
            flex: 1;
            padding: 10px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 5px;
        }
        .chart-wrapper {
            position: relative;
            background: #1a1a2e;
            border-radius: 8px;
            overflow: hidden;
        }
        .chart-wrapper .chart {
            width: 100%;
            height: 100%;
        }
        .chart-label {
            position: absolute;
            top: 5px;
            left: 10px;
            background: rgba(22, 33, 62, 0.9);
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.75rem;
            color: #4cc9f0;
            z-index: 10;
            font-weight: bold;
        }
        .chart-wrapper.active {
            outline: 2px solid #4cc9f0;
        }
        .info-bar {
            position: absolute;
            top: 90px;
            left: 20px;
            background: rgba(22, 33, 62, 0.9);
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 0.85rem;
            z-index: 100;
        }
        .info-bar .price {
            font-size: 1.1rem;
            font-weight: bold;
        }
        .info-bar .up { color: #26a69a; }
        .info-bar .down { color: #ef5350; }
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            color: #4cc9f0;
        }
        .error {
            color: #ef5350;
            padding: 20px;
            text-align: center;
        }

        /* Collector Panel */
        .collector-panel {
            width: 350px;
            background: #16213e;
            border-left: 1px solid #2B2B43;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        .panel-section {
            padding: 15px;
            border-bottom: 1px solid #2B2B43;
        }
        .panel-section h3 {
            color: #4cc9f0;
            font-size: 0.95rem;
            margin-bottom: 12px;
        }
        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .status-item {
            background: #0f3460;
            padding: 8px 12px;
            border-radius: 4px;
        }
        .status-item .label {
            font-size: 0.75rem;
            color: #888;
        }
        .status-item .value {
            font-size: 1rem;
            font-weight: bold;
        }
        .status-running { color: #26a69a; }
        .status-stopped { color: #ef5350; }
        .collector-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .collector-controls button {
            flex: 1;
        }

        /* Thought Input */
        .thought-input-section {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .pending-actions {
            margin-bottom: 10px;
        }
        .pending-action {
            background: #7b2cbf;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 8px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .pending-action .action-type {
            font-weight: bold;
            font-size: 1.1rem;
        }
        .pending-action .action-time {
            font-size: 0.8rem;
            color: #ddd;
        }
        .thought-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .thought-form textarea {
            background: #0f3460;
            border: 1px solid #4cc9f0;
            color: #fff;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.9rem;
            resize: vertical;
            min-height: 100px;
        }
        .thought-form textarea:focus {
            outline: none;
            border-color: #7b2cbf;
        }
        .thought-form select {
            width: 100%;
        }

        /* Recent Data */
        .recent-data {
            max-height: 200px;
            overflow-y: auto;
        }
        .data-item {
            background: #0f3460;
            padding: 8px 10px;
            border-radius: 4px;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }
        .data-item .action-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-right: 8px;
        }
        .action-BUY { background: #26a69a; }
        .action-SELL { background: #4cc9f0; }
        .action-STOP_LOSS { background: #ef5350; }
        .action-HOLD { background: #555; }
        .data-item .thought-preview {
            color: #888;
            font-size: 0.8rem;
            margin-top: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Drawing Tools */
        .drawing-toolbar {
            position: absolute;
            top: 90px;
            right: 370px;
            background: rgba(22, 33, 62, 0.95);
            padding: 8px;
            border-radius: 4px;
            z-index: 100;
            display: flex;
            gap: 5px;
            flex-direction: column;
        }
        .drawing-toolbar button {
            width: 40px;
            height: 40px;
            padding: 5px;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .drawing-toolbar button.active {
            background: #7b2cbf;
            color: #fff;
        }
        .drawing-toolbar button:hover {
            background: #4cc9f0;
        }
        .color-picker-container {
            display: flex;
            gap: 3px;
            flex-wrap: wrap;
            max-width: 90px;
        }
        .color-btn {
            width: 20px !important;
            height: 20px !important;
            min-width: 20px;
            padding: 0 !important;
            border-radius: 3px !important;
        }
        .color-btn.selected {
            outline: 2px solid #fff;
        }
        .drawing-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(22, 33, 62, 0.9);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            color: #888;
            z-index: 100;
        }
        .lines-list {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 8px;
        }
        .line-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: #0f3460;
            border-radius: 3px;
            margin-bottom: 4px;
            font-size: 0.8rem;
        }
        .line-item .line-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 8px;
        }
        .line-item .delete-line {
            background: #ef5350;
            padding: 2px 6px;
            font-size: 0.7rem;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>MT5 TraderÊÄùËÄÉËß£Êûê & Â£≤Ë≤∑„Ç∑„Çπ„ÉÜ„É†</h1>
        <div class="controls">
            <div class="control-group">
                <label>ÈäòÊüÑ:</label>
                <select id="symbol">
                    <option value="XAUUSD">XAUUSD</option>
                </select>
            </div>
            <div class="control-group">
                <label>Êú¨Êï∞:</label>
                <input type="number" id="count" value="100" min="10" max="500" style="width: 80px;">
            </div>
            <button id="loadBtn">Êõ¥Êñ∞</button>
            <span style="color: #888; font-size: 0.8rem; margin-left: 10px;">Ë°®Á§∫: H4 / M15 / M5 / M1</span>
        </div>
    </div>

    <div class="main-container">
        <div class="info-bar" id="infoBar">
            <span id="symbolInfo">XAUUSD</span> |
            <span id="priceInfo" class="price">---</span>
        </div>

        <!-- Drawing Toolbar -->
        <div class="drawing-toolbar">
            <button id="drawHLine" title="Ê∞¥Âπ≥Á∑ö (H)">‚Äï</button>
            <button id="drawTrendLine" title="„Éà„É¨„É≥„Éâ„É©„Ç§„É≥ (T)">‚ï±</button>
            <button id="drawPointer" title="ÈÅ∏Êäû„É¢„Éº„Éâ (Esc)" class="active">‚Üñ</button>
            <hr style="border-color: #2B2B43; margin: 5px 0;">
            <div class="color-picker-container">
                <button class="color-btn selected" style="background: #ef5350;" data-color="#ef5350"></button>
                <button class="color-btn" style="background: #26a69a;" data-color="#26a69a"></button>
                <button class="color-btn" style="background: #4cc9f0;" data-color="#4cc9f0"></button>
                <button class="color-btn" style="background: #ffeb3b;" data-color="#ffeb3b"></button>
                <button class="color-btn" style="background: #ff9800;" data-color="#ff9800"></button>
                <button class="color-btn" style="background: #ffffff;" data-color="#ffffff"></button>
            </div>
            <hr style="border-color: #2B2B43; margin: 5px 0;">
            <button id="deleteAllLines" title="ÂÖ®ÂâäÈô§">üóë</button>
        </div>

        <div class="drawing-info" id="drawingInfo" style="display: none;">
            <span id="drawingMode">Ê∞¥Âπ≥Á∑ö„É¢„Éº„Éâ: „ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÖçÁΩÆ</span>
        </div>

        <div id="chart-container">
            <div class="chart-wrapper active" data-timeframe="H4">
                <div class="chart-label">4ÊôÇÈñìË∂≥ (H4)</div>
                <div class="chart" id="chart-H4"></div>
            </div>
            <div class="chart-wrapper" data-timeframe="M15">
                <div class="chart-label">15ÂàÜË∂≥ (M15)</div>
                <div class="chart" id="chart-M15"></div>
            </div>
            <div class="chart-wrapper" data-timeframe="M5">
                <div class="chart-label">5ÂàÜË∂≥ (M5)</div>
                <div class="chart" id="chart-M5"></div>
            </div>
            <div class="chart-wrapper" data-timeframe="M1">
                <div class="chart-label">1ÂàÜË∂≥ (M1)</div>
                <div class="chart" id="chart-M1"></div>
            </div>
        </div>

        <div class="collector-panel">
            <!-- Session Section -->
            <div class="panel-section">
                <h3>„Çª„ÉÉ„Ç∑„Éß„É≥ÁÆ°ÁêÜ</h3>
                <div class="status-grid">
                    <div class="status-item" style="grid-column: span 2;">
                        <div class="label">„Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖã</div>
                        <div class="value" id="sessionStatus">„Å™„Åó</div>
                    </div>
                </div>
                <div class="session-thought-input" style="margin-top: 10px;">
                    <textarea id="sessionThoughtInput" placeholder="„Åì„ÅÆÂà§Êñ≠„ÅÆÁêÜÁî±„ÇíÂÖ•Âäõ...&#10;‰æã: 15ÂàÜË∂≥„Åß„ÉÄ„Éñ„É´„Éú„Éà„É†Á¢∫Ë™ç„ÄÅ1ÂàÜË∂≥„Åß„É™„ÉÜ„Çπ„ÉàÁô∫Áîü" style="background: #0f3460; border: 1px solid #4cc9f0; color: #fff; padding: 10px; border-radius: 4px; font-size: 0.9rem; resize: vertical; width: 100%; min-height: 80px; box-sizing: border-box;"></textarea>
                </div>
                <div class="session-controls" style="display: flex; flex-direction: column; gap: 8px; margin-top: 10px;">
                    <button class="btn-start" id="sessionStartBtn" onclick="startSession()" style="width: 100%;">BUY „Ç®„É≥„Éà„É™„ÉºÈñãÂßã</button>
                    <button id="sessionHoldBtn" onclick="addSessionHold()" disabled style="width: 100%; background: #555;">HOLD Ë®òÈå≤</button>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn-stop" id="sessionSellBtn" onclick="endSession('SELL')" disabled style="flex: 1;">SELL Ê±∫Ê∏à</button>
                        <button style="flex: 1; background: #ff9800;" id="sessionStopLossBtn" onclick="endSession('STOP_LOSS')" disabled>STOP_LOSS</button>
                    </div>
                </div>
            </div>

            <!-- Status Section -->
            <div class="panel-section">
                <h3>„Éá„Éº„ÇøÂèéÈõÜ</h3>
                <div class="status-grid">
                    <div class="status-item">
                        <div class="label">Áä∂ÊÖã</div>
                        <div class="value" id="collectorStatus">ÂÅúÊ≠¢‰∏≠</div>
                    </div>
                    <div class="status-item">
                        <div class="label">„Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„Éà</div>
                        <div class="value" id="screenshotCount">0</div>
                    </div>
                    <div class="status-item">
                        <div class="label">„Ç¢„ÇØ„Ç∑„Éß„É≥Ê§úÂá∫</div>
                        <div class="value" id="actionCount">0</div>
                    </div>
                    <div class="status-item">
                        <div class="label">ÊúÄÁµÇÊõ¥Êñ∞</div>
                        <div class="value" id="lastUpdate">---</div>
                    </div>
                </div>
                <div class="collector-controls">
                    <button class="btn-start" id="startBtn" onclick="startCollector()">ÈñãÂßã</button>
                    <button class="btn-stop" id="stopBtn" onclick="stopCollector()" disabled>ÂÅúÊ≠¢</button>
                </div>
            </div>

            <!-- Thought Input Section -->
            <div class="panel-section thought-input-section">
                <h3>ÊÄùËÄÉÂÖ•Âäõ</h3>
                <div class="pending-actions" id="pendingActions">
                    <!-- Pending actions will be inserted here -->
                </div>
                <div class="thought-form">
                    <select id="actionSelect">
                        <option value="BUY">Ë≤∑„ÅÑ„Ç®„É≥„Éà„É™„Éº (BUY)</option>
                        <option value="SELL">Ê±∫Ê∏à„ÉªÂà©Á¢∫ (SELL)</option>
                        <option value="STOP_LOSS">ÊêçÂàá„Çä (STOP_LOSS)</option>
                        <option value="HOLD">Ë¶ãÈÄÅ„Çä (HOLD)</option>
                    </select>
                    <textarea id="thoughtInput" placeholder="„Åì„ÅÆÂà§Êñ≠„Çí„Åó„ÅüÁêÜÁî±„ÇíÂÖ•Âäõ...&#10;‰æã: RSI30‰ª•‰∏ã„ÅßÂèçÁô∫„ÄÅ„Çµ„Éù„Éº„Éà„É©„Ç§„É≥„ÅßË≤∑„ÅÑ„Ç®„É≥„Éà„É™„Éº"></textarea>
                    <button onclick="submitThought()">ÊÄùËÄÉ„ÇíË®òÈå≤</button>
                </div>
            </div>

            <!-- Recent Data Section -->
            <div class="panel-section">
                <h3>ÊúÄËøë„ÅÆË®òÈå≤</h3>
                <div class="recent-data" id="recentData">
                    <!-- Recent data will be inserted here -->
                </div>
            </div>
        </div>
    </div>

    <div class="loading" id="loading" style="display: none;">Ë™≠„ÅøËæº„Åø‰∏≠...</div>

    <script>
        // Multi-chart state
        const TIMEFRAMES = ['H4', 'M15', 'M5', 'M1'];
        let charts = {}; // { H4: { chart, candleSeries, volumeSeries, canvas, ctx, drawnLines, trendLines } }
        let activeTimeframe = 'H4';
        let ws = null;
        let statusInterval = null;

        // Drawing state
        let drawingMode = 'pointer'; // 'pointer', 'hline', 'trendline'
        let selectedColor = '#ef5350';
        let trendLineStart = null;
        let lineIdCounter = 0;

        // „ÉÅ„É£„Éº„ÉàÂàùÊúüÂåñÔºàË§áÊï∞„ÉÅ„É£„Éº„ÉàÂØæÂøúÔºâ
        function initChart() {
            TIMEFRAMES.forEach(tf => {
                const container = document.getElementById(`chart-${tf}`);
                const wrapper = container.parentElement;

                const chart = LightweightCharts.createChart(container, {
                    layout: {
                        background: { type: 'solid', color: '#1a1a2e' },
                        textColor: '#d1d4dc',
                    },
                    grid: {
                        vertLines: { color: '#2B2B43' },
                        horzLines: { color: '#2B2B43' },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                    },
                    rightPriceScale: {
                        borderColor: '#2B2B43',
                    },
                    timeScale: {
                        borderColor: '#2B2B43',
                        timeVisible: true,
                        secondsVisible: false,
                    },
                });

                // „É≠„Éº„ÇΩ„ÇØË∂≥„Ç∑„É™„Éº„Ç∫
                const candleSeries = chart.addCandlestickSeries({
                    upColor: '#26a69a',
                    downColor: '#ef5350',
                    borderDownColor: '#ef5350',
                    borderUpColor: '#26a69a',
                    wickDownColor: '#ef5350',
                    wickUpColor: '#26a69a',
                });

                // Âá∫Êù•È´ò„Ç∑„É™„Éº„Ç∫
                const volumeSeries = chart.addHistogramSeries({
                    color: '#4cc9f0',
                    priceFormat: {
                        type: 'volume',
                    },
                    priceScaleId: '',
                    scaleMargins: {
                        top: 0.85,
                        bottom: 0,
                    },
                });

                // „ÇØ„É≠„Çπ„Éò„Ç¢ÁßªÂãïÊôÇ„ÅÆÊÉÖÂ†±Êõ¥Êñ∞
                chart.subscribeCrosshairMove((param) => {
                    if (param.time && param.seriesData.get(candleSeries)) {
                        const data = param.seriesData.get(candleSeries);
                        updatePriceInfo(data, tf);
                    }
                });

                // „Éà„É¨„É≥„Éâ„É©„Ç§„É≥Áî®„Ç≠„É£„É≥„Éê„Çπ
                const canvas = document.createElement('canvas');
                canvas.className = 'trendline-canvas';
                canvas.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    pointer-events: none;
                    z-index: 5;
                `;
                wrapper.appendChild(canvas);
                const ctx = canvas.getContext('2d');

                // „ÉÅ„É£„Éº„ÉàÊÉÖÂ†±„Çí‰øùÂ≠ò
                charts[tf] = {
                    chart,
                    candleSeries,
                    volumeSeries,
                    canvas,
                    ctx,
                    drawnLines: [],
                    trendLines: [],
                    container,
                    wrapper
                };

                // „ÇØ„É™„ÉÉ„ÇØ„Åß„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„ÉÅ„É£„Éº„ÉàÂàá„ÇäÊõø„Åà
                wrapper.addEventListener('click', () => {
                    setActiveChart(tf);
                });

                // „ÉÅ„É£„Éº„Éà„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„ÉàÔºàÊèèÁîªÁî®Ôºâ
                chart.subscribeClick((param) => {
                    if (activeTimeframe !== tf) {
                        setActiveChart(tf);
                        return;
                    }
                    handleChartClick(tf, param);
                });

                // „Çπ„ÇØ„É≠„Éº„É´/„Ç∫„Éº„É†ÊôÇ„Å´ÂÜçÊèèÁîª
                chart.timeScale().subscribeVisibleTimeRangeChange(() => {
                    drawAllTrendLines(tf);
                });
            });

            // „É™„Çµ„Ç§„Ç∫ÂØæÂøú
            window.addEventListener('resize', () => {
                TIMEFRAMES.forEach(tf => {
                    const { chart, container, canvas } = charts[tf];
                    chart.applyOptions({
                        width: container.clientWidth,
                        height: container.clientHeight,
                    });
                    canvas.width = container.clientWidth;
                    canvas.height = container.clientHeight;
                    drawAllTrendLines(tf);
                });
            });
        }

        // „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„ÉÅ„É£„Éº„ÉàÂàá„ÇäÊõø„Åà
        function setActiveChart(tf) {
            activeTimeframe = tf;
            document.querySelectorAll('.chart-wrapper').forEach(w => {
                w.classList.remove('active');
            });
            charts[tf].wrapper.classList.add('active');
        }

        // ‰æ°Ê†ºÊÉÖÂ†±Êõ¥Êñ∞
        function updatePriceInfo(data, tf = null) {
            const priceInfo = document.getElementById('priceInfo');
            const change = data.close - data.open;
            const changeClass = change >= 0 ? 'up' : 'down';
            const sign = change >= 0 ? '+' : '';
            const tfLabel = tf ? `[${tf}] ` : '';

            priceInfo.innerHTML = `
                ${tfLabel}O: ${data.open.toFixed(2)}
                H: ${data.high.toFixed(2)}
                L: ${data.low.toFixed(2)}
                C: <span class="${changeClass}">${data.close.toFixed(2)} (${sign}${change.toFixed(2)})</span>
            `;
        }

        // ÈäòÊüÑ‰∏ÄË¶ß„ÇíÂèñÂæó
        async function loadSymbols() {
            try {
                const res = await fetch('/api/symbols');
                const data = await res.json();
                const select = document.getElementById('symbol');
                select.innerHTML = '';
                data.symbols.forEach(s => {
                    const option = document.createElement('option');
                    option.value = s;
                    option.textContent = s;
                    if (s === 'XAUUSD') option.selected = true;
                    select.appendChild(option);
                });
            } catch (e) {
                console.error('ÈäòÊüÑÂèñÂæó„Ç®„É©„Éº:', e);
            }
        }

        // OHLC„Éá„Éº„Çø„ÇíÂèñÂæó„Åó„Å¶„ÉÅ„É£„Éº„ÉàÊõ¥Êñ∞ÔºàÂÖ®4„ÉÅ„É£„Éº„ÉàÔºâ
        async function loadOHLC() {
            const symbol = document.getElementById('symbol').value;
            const count = document.getElementById('count').value;

            document.getElementById('loading').style.display = 'block';
            document.getElementById('loadBtn').disabled = true;

            try {
                // ÂÖ®4ÊôÇÈñìË∂≥„ÅÆ„Éá„Éº„Çø„Çí‰∏¶ÂàóÂèñÂæó
                const promises = TIMEFRAMES.map(tf =>
                    fetch(`/api/ohlc?symbol=${symbol}&timeframe=${tf}&count=${count}`)
                        .then(res => res.json())
                        .then(data => ({ tf, data }))
                );

                const results = await Promise.all(promises);
                let hasData = false;

                results.forEach(({ tf, data }) => {
                    if (data.data && data.data.length > 0) {
                        hasData = true;
                        const chartObj = charts[tf];

                        // Êó¢Â≠ò„ÅÆÁ∑ö„Çí„ÇØ„É™„Ç¢
                        chartObj.drawnLines.forEach(line => {
                            try { chartObj.candleSeries.removePriceLine(line.lineObj); } catch(e) {}
                        });
                        chartObj.drawnLines = [];
                        chartObj.trendLines = [];

                        // „É≠„Éº„ÇΩ„ÇØË∂≥„Éá„Éº„Çø„Çí„Çª„ÉÉ„Éà
                        chartObj.candleSeries.setData(data.data);

                        // Âá∫Êù•È´ò„Éá„Éº„Çø„Çí„Çª„ÉÉ„Éà
                        const volumeData = data.data.map(d => ({
                            time: d.time,
                            value: d.volume,
                            color: d.close >= d.open ? '#26a69a50' : '#ef535050',
                        }));
                        chartObj.volumeSeries.setData(volumeData);

                        // „ÉÅ„É£„Éº„Éà„Çí„Éï„Ç£„ÉÉ„Éà
                        chartObj.chart.timeScale().fitContent();

                        // „Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫Ë™øÊï¥
                        chartObj.canvas.width = chartObj.container.clientWidth;
                        chartObj.canvas.height = chartObj.container.clientHeight;
                    }
                });

                if (hasData) {
                    // ÂÖ±ÊúâÊ∞¥Âπ≥Á∑ö„ÇíË™≠„ÅøËæº„ÅøÔºàÂÖ®„ÉÅ„É£„Éº„Éà„Å´ÈÅ©Áî®Ôºâ
                    loadSharedLinesFromStorage();

                    // ÂêÑ„ÉÅ„É£„Éº„Éà„ÅÆ„Éà„É¨„É≥„Éâ„É©„Ç§„É≥„ÇíË™≠„ÅøËæº„Åø
                    TIMEFRAMES.forEach(tf => {
                        loadLinesFromStorage(tf);
                        setTimeout(() => drawAllTrendLines(tf), 100);
                    });
                }

                // ÈäòÊüÑÂêçÊõ¥Êñ∞
                document.getElementById('symbolInfo').textContent = symbol;

                if (!hasData) {
                    alert('„Éá„Éº„Çø„ÅåÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇMT5„ÅåËµ∑Âãï„Åó„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                }
            } catch (e) {
                console.error('„Éá„Éº„ÇøÂèñÂæó„Ç®„É©„Éº:', e);
                alert('„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ' + e.message);
            } finally {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('loadBtn').disabled = false;
            }
        }

        // ============ Session Functions ============

        // „Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖã„ÇíÊõ¥Êñ∞
        async function updateSessionStatus() {
            try {
                const res = await fetch('/api/sessions/active');
                const data = await res.json();

                const statusEl = document.getElementById('sessionStatus');
                const startBtn = document.getElementById('sessionStartBtn');
                const holdBtn = document.getElementById('sessionHoldBtn');
                const sellBtn = document.getElementById('sessionSellBtn');
                const stopLossBtn = document.getElementById('sessionStopLossBtn');

                if (data.session) {
                    statusEl.textContent = `${data.session.session_id} (${data.session.status})`;
                    statusEl.className = 'value status-running';
                    startBtn.disabled = true;
                    holdBtn.disabled = false;
                    holdBtn.style.background = '#4cc9f0';
                    sellBtn.disabled = false;
                    stopLossBtn.disabled = false;
                } else {
                    statusEl.textContent = '„Å™„Åó';
                    statusEl.className = 'value';
                    startBtn.disabled = false;
                    holdBtn.disabled = true;
                    holdBtn.style.background = '#555';
                    sellBtn.disabled = true;
                    stopLossBtn.disabled = true;
                }
            } catch (e) {
                console.error('Session status update error:', e);
            }
        }

        // „Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßãÔºàBUYÔºâ
        async function startSession() {
            const thought = document.getElementById('sessionThoughtInput').value.trim();
            if (!thought) {
                alert('ÊÄùËÄÉ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }

            try {
                const res = await fetch('/api/sessions/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ thought })
                });
                const data = await res.json();
                console.log('Session started:', data);

                document.getElementById('sessionThoughtInput').value = '';
                await updateSessionStatus();
                await updateRecentData();
            } catch (e) {
                console.error('Start session error:', e);
                alert('„Çª„ÉÉ„Ç∑„Éß„É≥„ÅÆÈñãÂßã„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
            }
        }

        // HOLDËøΩÂä†
        async function addSessionHold() {
            const thought = document.getElementById('sessionThoughtInput').value.trim();
            if (!thought) {
                alert('ÊÄùËÄÉ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }

            try {
                const res = await fetch('/api/sessions/hold', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ thought })
                });
                const data = await res.json();
                console.log('HOLD added:', data);

                document.getElementById('sessionThoughtInput').value = '';
                await updateSessionStatus();
                await updateRecentData();
            } catch (e) {
                console.error('Add hold error:', e);
                alert('HOLD„ÅÆËøΩÂä†„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
            }
        }

        // „Çª„ÉÉ„Ç∑„Éß„É≥ÁµÇ‰∫ÜÔºàSELL/STOP_LOSSÔºâ
        async function endSession(action) {
            const thought = document.getElementById('sessionThoughtInput').value.trim();
            if (!thought) {
                alert('ÊÄùËÄÉ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }

            try {
                const res = await fetch('/api/sessions/end', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action, thought })
                });
                const data = await res.json();
                console.log('Session ended:', data);

                document.getElementById('sessionThoughtInput').value = '';
                await updateSessionStatus();
                await updateRecentData();
            } catch (e) {
                console.error('End session error:', e);
                alert('„Çª„ÉÉ„Ç∑„Éß„É≥„ÅÆÁµÇ‰∫Ü„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
            }
        }

        // ============ Collector Functions ============

        // „Ç≥„É¨„ÇØ„Çø„Éº„ÅÆÁä∂ÊÖã„ÇíÊõ¥Êñ∞
        async function updateCollectorStatus() {
            try {
                const res = await fetch('/api/collector/status');
                const status = await res.json();

                const statusEl = document.getElementById('collectorStatus');
                if (status.is_running) {
                    statusEl.textContent = 'ÂÆüË°å‰∏≠';
                    statusEl.className = 'value status-running';
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                } else {
                    statusEl.textContent = 'ÂÅúÊ≠¢‰∏≠';
                    statusEl.className = 'value status-stopped';
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                }

                document.getElementById('screenshotCount').textContent = status.screenshots_count || 0;
                document.getElementById('actionCount').textContent = status.actions_count || 0;

                if (status.last_screenshot_at) {
                    const time = new Date(status.last_screenshot_at);
                    document.getElementById('lastUpdate').textContent = time.toLocaleTimeString('ja-JP');
                }

            } catch (e) {
                console.error('Status update error:', e);
            }
        }

        // ‰øùÁïô‰∏≠„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÊõ¥Êñ∞
        async function updatePendingActions() {
            try {
                const res = await fetch('/api/collector/pending-actions');
                const data = await res.json();
                const container = document.getElementById('pendingActions');

                if (data.pending_actions && data.pending_actions.length > 0) {
                    container.innerHTML = data.pending_actions.map(action => `
                        <div class="pending-action">
                            <div class="action-type">${action.action} - ÊÄùËÄÉÂÖ•ÂäõÂæÖ„Å°</div>
                            <div class="action-time">${new Date(action.timestamp).toLocaleString('ja-JP')}</div>
                        </div>
                    `).join('');

                    // Ëá™Âãï„Åß„Ç¢„ÇØ„Ç∑„Éß„É≥„Çø„Ç§„Éó„ÇíÈÅ∏Êäû
                    document.getElementById('actionSelect').value = data.pending_actions[0].action;
                } else {
                    container.innerHTML = '<p style="color: #888; font-size: 0.85rem;">ÂæÖÊ©ü‰∏≠„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì</p>';
                }
            } catch (e) {
                console.error('Pending actions update error:', e);
            }
        }

        // ÊúÄËøë„ÅÆ„Éá„Éº„Çø„ÇíÊõ¥Êñ∞
        async function updateRecentData() {
            try {
                const res = await fetch('/api/collector/recent-data?limit=5');
                const data = await res.json();
                const container = document.getElementById('recentData');

                if (data.data && data.data.length > 0) {
                    container.innerHTML = data.data.reverse().map(item => `
                        <div class="data-item">
                            <span class="action-badge action-${item.action}">${item.action}</span>
                            <span>${new Date(item.timestamp).toLocaleTimeString('ja-JP')}</span>
                            ${item.thought ? `<div class="thought-preview">${item.thought}</div>` : ''}
                        </div>
                    `).join('');
                } else {
                    container.innerHTML = '<p style="color: #888; font-size: 0.85rem;">„Åæ„Å†„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>';
                }
            } catch (e) {
                console.error('Recent data update error:', e);
            }
        }

        // „Ç≥„É¨„ÇØ„Çø„ÉºÈñãÂßã
        async function startCollector() {
            try {
                const res = await fetch('/api/collector/start', { method: 'POST' });
                const data = await res.json();
                console.log('Collector started:', data);
                await updateCollectorStatus();

                // ÂÆöÊúüÁöÑ„Å´Áä∂ÊÖã„ÇíÊõ¥Êñ∞
                statusInterval = setInterval(() => {
                    updateCollectorStatus();
                    updatePendingActions();
                    updateRecentData();
                }, 5000);

            } catch (e) {
                console.error('Start collector error:', e);
                alert('„Ç≥„É¨„ÇØ„Çø„Éº„ÅÆÈñãÂßã„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
            }
        }

        // „Ç≥„É¨„ÇØ„Çø„ÉºÂÅúÊ≠¢
        async function stopCollector() {
            try {
                const res = await fetch('/api/collector/stop', { method: 'POST' });
                const data = await res.json();
                console.log('Collector stopped:', data);
                await updateCollectorStatus();

                // ÂÆöÊúüÊõ¥Êñ∞„ÇíÂÅúÊ≠¢
                if (statusInterval) {
                    clearInterval(statusInterval);
                    statusInterval = null;
                }

            } catch (e) {
                console.error('Stop collector error:', e);
                alert('„Ç≥„É¨„ÇØ„Çø„Éº„ÅÆÂÅúÊ≠¢„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
            }
        }

        // ÊÄùËÄÉ„ÇíÈÄÅ‰ø°
        async function submitThought() {
            const thought = document.getElementById('thoughtInput').value.trim();
            const action = document.getElementById('actionSelect').value;

            if (!thought) {
                alert('ÊÄùËÄÉ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }

            try {
                const res = await fetch('/api/collector/thought', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ thought, action })
                });
                const data = await res.json();
                console.log('Thought submitted:', data);

                // ÂÖ•Âäõ„Çí„ÇØ„É™„Ç¢
                document.getElementById('thoughtInput').value = '';

                // Êõ¥Êñ∞
                await updatePendingActions();
                await updateRecentData();

            } catch (e) {
                console.error('Submit thought error:', e);
                alert('ÊÄùËÄÉ„ÅÆÈÄÅ‰ø°„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
            }
        }

        // WebSocketÊé•Á∂ö
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws/collector`);

            ws.onopen = () => {
                console.log('WebSocket connected');
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                console.log('WebSocket message:', data);

                if (data.type === 'action_detected') {
                    // „Ç¢„ÇØ„Ç∑„Éß„É≥Ê§úÂá∫ÊôÇ„ÅÆÈÄöÁü•
                    updatePendingActions();
                    // ÈÄöÁü•Èü≥„ÇíÈ≥¥„Çâ„ÅôÔºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
                    // new Audio('/notification.mp3').play();
                } else if (data.type === 'thought_submitted') {
                    updateRecentData();
                }
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected, reconnecting...');
                setTimeout(connectWebSocket, 3000);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }

        // ============ Drawing Functions ============

        // Â∫ßÊ®ôÂ§âÊèõ
        function priceToY(tf, price) {
            const coordinate = charts[tf].candleSeries.priceToCoordinate(price);
            return coordinate;
        }

        function timeToX(tf, time) {
            const coordinate = charts[tf].chart.timeScale().timeToCoordinate(time);
            return coordinate;
        }

        // ÂÖ®„Éà„É¨„É≥„Éâ„É©„Ç§„É≥ÂÜçÊèèÁîª
        function drawAllTrendLines(tf) {
            const chartObj = charts[tf];
            if (!chartObj || !chartObj.ctx) return;

            const ctx = chartObj.ctx;
            const canvas = chartObj.canvas;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            chartObj.trendLines.forEach(line => {
                if (line.points.length === 2) {
                    const x1 = timeToX(tf, line.points[0].time);
                    const y1 = priceToY(tf, line.points[0].price);
                    const x2 = timeToX(tf, line.points[1].time);
                    const y2 = priceToY(tf, line.points[1].price);

                    if (x1 !== null && y1 !== null && x2 !== null && y2 !== null) {
                        // Á∑ö„ÇíÂª∂Èï∑„Åó„Å¶ÊèèÁîª
                        const dx = x2 - x1;
                        const dy = y2 - y1;
                        const extendFactor = 10;

                        ctx.beginPath();
                        ctx.strokeStyle = line.color;
                        ctx.lineWidth = 2;
                        ctx.moveTo(x1 - dx * extendFactor, y1 - dy * extendFactor);
                        ctx.lineTo(x2 + dx * extendFactor, y2 + dy * extendFactor);
                        ctx.stroke();

                        // ÂßãÁÇπ„ÉªÁµÇÁÇπ„Éû„Éº„Ç´„Éº
                        ctx.fillStyle = line.color;
                        ctx.beginPath();
                        ctx.arc(x1, y1, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(x2, y2, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });

            // ÊèèÁîª‰∏≠„ÅÆ„Éà„É¨„É≥„Éâ„É©„Ç§„É≥Ôºà„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„ÉÅ„É£„Éº„Éà„ÅÆ„ÅøÔºâ
            if (tf === activeTimeframe && trendLineStart && drawingMode === 'trendline') {
                const x1 = timeToX(tf, trendLineStart.time);
                const y1 = priceToY(tf, trendLineStart.price);
                if (x1 !== null && y1 !== null) {
                    ctx.fillStyle = selectedColor;
                    ctx.beginPath();
                    ctx.arc(x1, y1, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // „ÉÅ„É£„Éº„Éà„ÇØ„É™„ÉÉ„ÇØ„Éè„É≥„Éâ„É©
        function handleChartClick(tf, param) {
            if (drawingMode === 'pointer') return;

            const chartObj = charts[tf];
            const price = chartObj.candleSeries.coordinateToPrice(param.point.y);
            const time = chartObj.chart.timeScale().coordinateToTime(param.point.x);

            if (price === null || time === null) return;

            if (drawingMode === 'hline') {
                addHorizontalLine(tf, price);
            } else if (drawingMode === 'trendline') {
                if (!trendLineStart) {
                    trendLineStart = { time, price };
                    document.getElementById('drawingMode').textContent = '„Éà„É¨„É≥„Éâ„É©„Ç§„É≥: 2ÁÇπÁõÆ„Çí„ÇØ„É™„ÉÉ„ÇØ';
                    drawAllTrendLines(tf);
                } else {
                    addTrendLine(tf, trendLineStart, { time, price });
                    trendLineStart = null;
                    document.getElementById('drawingMode').textContent = '„Éà„É¨„É≥„Éâ„É©„Ç§„É≥: 2ÁÇπ„Çí„ÇØ„É™„ÉÉ„ÇØ';
                }
            }
        }

        // ÊèèÁîª„É¢„Éº„ÉâË®≠ÂÆö
        function setDrawingMode(mode) {
            drawingMode = mode;
            document.querySelectorAll('.drawing-toolbar button:not(.color-btn)').forEach(btn => {
                btn.classList.remove('active');
            });

            const infoEl = document.getElementById('drawingInfo');
            const modeEl = document.getElementById('drawingMode');

            switch (mode) {
                case 'hline':
                    document.getElementById('drawHLine').classList.add('active');
                    infoEl.style.display = 'block';
                    modeEl.textContent = 'Ê∞¥Âπ≥Á∑ö„É¢„Éº„Éâ: „ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÖçÁΩÆ';
                    break;
                case 'trendline':
                    document.getElementById('drawTrendLine').classList.add('active');
                    infoEl.style.display = 'block';
                    modeEl.textContent = '„Éà„É¨„É≥„Éâ„É©„Ç§„É≥: 2ÁÇπ„Çí„ÇØ„É™„ÉÉ„ÇØ';
                    trendLineStart = null;
                    break;
                default:
                    document.getElementById('drawPointer').classList.add('active');
                    infoEl.style.display = 'none';
                    trendLineStart = null;
                    TIMEFRAMES.forEach(tf => drawAllTrendLines(tf));
            }
        }

        // Ê∞¥Âπ≥Á∑öËøΩÂä†ÔºàÂÖ®„ÉÅ„É£„Éº„ÉàÂÖ±ÊúâÔºâ
        function addHorizontalLine(tf, price) {
            const id = ++lineIdCounter;

            // ÂÖ®„ÉÅ„É£„Éº„Éà„Å´Ê∞¥Âπ≥Á∑ö„ÇíËøΩÂä†
            TIMEFRAMES.forEach(timeframe => {
                const chartObj = charts[timeframe];
                const lineObj = chartObj.candleSeries.createPriceLine({
                    price: price,
                    color: selectedColor,
                    lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Solid,
                    axisLabelVisible: true,
                    title: '',
                });

                chartObj.drawnLines.push({
                    id: id,  // Âêå„ÅòID„ÅßÂÖ±Êúâ
                    type: 'hline',
                    price: price,
                    color: selectedColor,
                    lineObj: lineObj
                });
            });

            saveSharedLinesToStorage();
        }

        // „Éà„É¨„É≥„Éâ„É©„Ç§„É≥ËøΩÂä†
        function addTrendLine(tf, point1, point2) {
            const chartObj = charts[tf];
            const id = ++lineIdCounter;
            chartObj.trendLines.push({
                id: id,
                points: [point1, point2],
                color: selectedColor
            });

            drawAllTrendLines(tf);
            saveLinesToStorage(tf);
        }

        // Á∑ö„ÇíÂâäÈô§ÔºàÊ∞¥Âπ≥Á∑ö„ÅØÂÖ®„ÉÅ„É£„Éº„Éà„Åã„Çâ„ÄÅ„Éà„É¨„É≥„Éâ„É©„Ç§„É≥„ÅØ„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„ÉÅ„É£„Éº„Éà„Åã„ÇâÔºâ
        function deleteLastLine() {
            const chartObj = charts[activeTimeframe];

            // „Åæ„Åö„Éà„É¨„É≥„Éâ„É©„Ç§„É≥„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºà„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„ÉÅ„É£„Éº„Éà„ÅÆ„ÅøÔºâ
            if (chartObj.trendLines.length > 0) {
                chartObj.trendLines.pop();
                drawAllTrendLines(activeTimeframe);
                saveLinesToStorage(activeTimeframe);
                return;
            }

            // Ê∞¥Âπ≥Á∑ö„ÇíÂâäÈô§ÔºàÂÖ®„ÉÅ„É£„Éº„Éà„Åã„ÇâÔºâ
            if (chartObj.drawnLines.length > 0) {
                const last = chartObj.drawnLines[chartObj.drawnLines.length - 1];
                const lineId = last.id;

                // ÂÖ®„ÉÅ„É£„Éº„Éà„Åã„ÇâÂêå„ÅòID„ÅÆÊ∞¥Âπ≥Á∑ö„ÇíÂâäÈô§
                TIMEFRAMES.forEach(tf => {
                    const obj = charts[tf];
                    const index = obj.drawnLines.findIndex(l => l.id === lineId);
                    if (index !== -1) {
                        obj.candleSeries.removePriceLine(obj.drawnLines[index].lineObj);
                        obj.drawnLines.splice(index, 1);
                    }
                });
                saveSharedLinesToStorage();
            }
        }

        // ÂÖ®ÂâäÈô§
        function deleteAllLines() {
            // Ê∞¥Âπ≥Á∑ö„ÇíÂÖ®„ÉÅ„É£„Éº„Éà„Åã„ÇâÂâäÈô§
            TIMEFRAMES.forEach(tf => {
                const chartObj = charts[tf];
                chartObj.drawnLines.forEach(line => {
                    chartObj.candleSeries.removePriceLine(line.lineObj);
                });
                chartObj.drawnLines = [];
            });

            // „Éà„É¨„É≥„Éâ„É©„Ç§„É≥„ÅØ„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„ÉÅ„É£„Éº„Éà„ÅÆ„ÅøÂâäÈô§
            const activeChart = charts[activeTimeframe];
            activeChart.trendLines = [];
            drawAllTrendLines(activeTimeframe);

            saveSharedLinesToStorage();
            saveLinesToStorage(activeTimeframe);
        }

        // ÂÖ±ÊúâÊ∞¥Âπ≥Á∑ö„Çí„Çπ„Éà„É¨„Éº„Ç∏„Å´‰øùÂ≠ò
        function saveSharedLinesToStorage() {
            const symbol = document.getElementById('symbol').value;
            const key = `shared_hlines_${symbol}`;

            // ÊúÄÂàù„ÅÆ„ÉÅ„É£„Éº„Éà„Åã„ÇâÊ∞¥Âπ≥Á∑ö„Éá„Éº„Çø„ÇíÂèñÂæóÔºàÂÖ®„ÉÅ„É£„Éº„ÉàÂêå„Åò„Å™„ÅÆ„ÅßÔºâ
            const chartObj = charts[TIMEFRAMES[0]];
            const hlines = chartObj.drawnLines.map(l => ({
                id: l.id,
                price: l.price,
                color: l.color
            }));

            localStorage.setItem(key, JSON.stringify(hlines));
        }

        // „Éà„É¨„É≥„Éâ„É©„Ç§„É≥ÔºàÂÄãÂà•Ôºâ„Çí„Çπ„Éà„É¨„Éº„Ç∏„Å´‰øùÂ≠ò
        function saveLinesToStorage(tf) {
            const symbol = document.getElementById('symbol').value;
            const key = `trendlines_${symbol}_${tf}`;
            const chartObj = charts[tf];

            const trendlines = chartObj.trendLines.map(l => ({
                points: l.points,
                color: l.color
            }));
            localStorage.setItem(key, JSON.stringify(trendlines));
        }

        // ÂÖ±ÊúâÊ∞¥Âπ≥Á∑ö„Çí„Çπ„Éà„É¨„Éº„Ç∏„Åã„ÇâË™≠„ÅøËæº„ÅøÔºàÂàùÂõû„ÅÆ„ÅøÂëº„Å∂Ôºâ
        function loadSharedLinesFromStorage() {
            const symbol = document.getElementById('symbol').value;
            const key = `shared_hlines_${symbol}`;

            const saved = localStorage.getItem(key);
            if (!saved) return;

            try {
                const hlines = JSON.parse(saved);

                hlines.forEach(l => {
                    const id = l.id || ++lineIdCounter;
                    if (id > lineIdCounter) lineIdCounter = id;

                    // ÂÖ®„ÉÅ„É£„Éº„Éà„Å´Ê∞¥Âπ≥Á∑ö„ÇíËøΩÂä†
                    TIMEFRAMES.forEach(tf => {
                        const chartObj = charts[tf];
                        const lineObj = chartObj.candleSeries.createPriceLine({
                            price: l.price,
                            color: l.color,
                            lineWidth: 2,
                            lineStyle: LightweightCharts.LineStyle.Solid,
                            axisLabelVisible: true,
                        });
                        chartObj.drawnLines.push({
                            id: id,
                            type: 'hline',
                            price: l.price,
                            color: l.color,
                            lineObj: lineObj
                        });
                    });
                });
            } catch (e) {
                console.error('Failed to load shared lines:', e);
            }
        }

        // „Éà„É¨„É≥„Éâ„É©„Ç§„É≥ÔºàÂÄãÂà•Ôºâ„Çí„Çπ„Éà„É¨„Éº„Ç∏„Åã„ÇâË™≠„ÅøËæº„Åø
        function loadLinesFromStorage(tf) {
            const symbol = document.getElementById('symbol').value;
            const key = `trendlines_${symbol}_${tf}`;
            const chartObj = charts[tf];

            const saved = localStorage.getItem(key);
            if (!saved) return;

            try {
                const trendlines = JSON.parse(saved);

                trendlines.forEach(l => {
                    const id = ++lineIdCounter;
                    chartObj.trendLines.push({
                        id: id,
                        points: l.points,
                        color: l.color
                    });
                });
                drawAllTrendLines(tf);
            } catch (e) {
                console.error('Failed to load trendlines:', e);
            }
        }

        // ÂàùÊúüÂåñ
        document.addEventListener('DOMContentLoaded', async () => {
            initChart();
            await loadSymbols();
            await loadOHLC();

            // „Ç≥„É¨„ÇØ„Çø„ÉºÁä∂ÊÖã„ÅÆÂàùÊúüÂåñ
            await updateCollectorStatus();
            await updatePendingActions();
            await updateRecentData();

            // „Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖã„ÅÆÂàùÊúüÂåñ
            await updateSessionStatus();

            // WebSocketÊé•Á∂ö
            connectWebSocket();

            // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
            document.getElementById('loadBtn').addEventListener('click', loadOHLC);
            document.getElementById('symbol').addEventListener('change', loadOHLC);

            // Enter„Ç≠„Éº„ÅßÊÄùËÄÉ„ÇíÈÄÅ‰ø°
            document.getElementById('thoughtInput').addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && e.ctrlKey) {
                    submitThought();
                }
            });

            // ÊèèÁîª„ÉÑ„Éº„É´„Éê„Éº„Ç§„Éô„É≥„Éà
            document.getElementById('drawHLine').addEventListener('click', () => setDrawingMode('hline'));
            document.getElementById('drawTrendLine').addEventListener('click', () => setDrawingMode('trendline'));
            document.getElementById('drawPointer').addEventListener('click', () => setDrawingMode('pointer'));
            document.getElementById('deleteAllLines').addEventListener('click', () => {
                if (confirm('ÂÖ®„Å¶„ÅÆÁ∑ö„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
                    deleteAllLines();
                }
            });

            // „Ç´„É©„Éº„Éî„ÉÉ„Ç´„Éº
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectedColor = btn.dataset.color;
                });
            });

            // „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà
            document.addEventListener('keydown', (e) => {
                // „ÉÜ„Ç≠„Çπ„ÉàÂÖ•Âäõ‰∏≠„ÅØÁÑ°Ë¶ñ
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                    return;
                }

                switch (e.key.toLowerCase()) {
                    case 'h':
                        setDrawingMode('hline');
                        break;
                    case 't':
                        setDrawingMode('trendline');
                        break;
                    case 'escape':
                        setDrawingMode('pointer');
                        break;
                    case 'delete':
                    case 'backspace':
                        // ÊúÄÂæå„Å´ÊèèÁîª„Åó„ÅüÁ∑ö„ÇíÂâäÈô§
                        deleteLastLine();
                        break;
                }
            });
        });
    </script>
</body>
</html>
